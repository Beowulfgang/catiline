<!DOCTYPE html><html><head><style>
#test-container {
			position: relative;
			height: 40px;
		}
		#test1 {
			width: 40px;
			height: 40px;
			background: red;
			position: absolute;
		}
			#test2 {
			width: 40px;
			height: 40px;
			background: red;
			position: absolute;
		}
			#test3 {
			width: 40px;
			height: 40px;
			background: red;
			position: absolute;
		}
		</style>
	 <link href="bootstrap/css/bootstrap.css" rel="stylesheet">
	 <link href="bootstrap/css/bootstrap-responsive.css" rel="stylesheet">
	 <link rel="stylesheet" href="gh-fork-ribbon.css" />
	 <title>Workers!</title>
	 </head><body>
	 	<div class="github-fork-ribbon-wrapper right">
		<div class="github-fork-ribbon">
			<a href="https://github.com/calvinmetcalf/communist">Fork me on GitHub</a>
		</div>
	</div>
	 <div class="row-fluid">
	 	<div class="span10 offset 2"><div class="page-header">
	 		<h1 class="text-center">Loading data</h1></div></div></div><div class="row-fluid"><div class="span2"></div><div class="span4"><p>
	 	I was inpired by <a href="http://mourner.github.com/worker-data-load/">Mourner's data load test</a>, (where I took the code for the boxes) which is all well and good if we want to do all the calculations in one worker, but what if we want to divide it up amongst several workers for prossessing?</p>
	 	<p>Easy you say, you'll open some more workers inside your worker, but alas chrome hasn't gotten around to to implimenting nested worker, you're probobly going to have to transfer it back to the main thread first.</p>
	 	<p>Before we go any farther, we're going to be working with a massive 28MiB(12MiB gziped) text file, I'd hit the button to download dictionary now. The file in question is Webster's Unabridged English Dictionary origionally from project gutenberg, but I grabbed it from <a href="https://github.com/adambom/dictionary">this repo</a> </p>
	 	<p>The problem is that transfering between threads is a blocking operation, once the dictionary is done loading you'll see a button marked "Transfer with structured clone" hit it while looking at the boxes, you'll notice them jump. Here is where transferable objects come in, for certain JavaScript data types (array buffers) we can transfer ownership, this is slightly different 
	 	from sending messages as the object is no longer available in the origional context, to see this in action click it the button marked "Transfer with transferable objects" and again look at the boxes, no jump for me at least.</p>
	 	<p>We've actually done some pre-processing on the object so were actually transfering ownership of about 5000 seperate typed arrays which slows things down, if your curious you can <span id="tas"><button id="transArray" class="btn btn-small btn-primary disabled">Transfer as one array</button></span>, for me the preposessing increased the time it took to transfer by about 42%.</p>
	 	</div><div class="span4"><p>The down side of transferable objects is one I hinted at earler, you can only use it with array buffers(and message ports but I'm not sure that's implemented/what they are). Array buffers are the basis of typed arrays, buffers are abstract containers for bytes and typed arrays are representations with various byte lengths it is a non trivial task to convert a typed array back to text. With the array buffer version we turned the text into unsigned 16bit integers, I'd give you a demo of trying to convert it back in one go but it fills up the heap and crashes your browser.</p>
	 	<p>So instead we cut the text up into about 5000 pieces, to make it even we cut both the text and the array buffer version into arrays with the same number of pieces, then we fire up some more workers and shart handing out those pieces to them for a map reduce of letter frequencies. We send a piece to one of the mpa workers, it computes an object with with the numbers for each letter which it sends back, we send that to the reducer function and send the map function a new piece. Once we are out of data and we shut down the map workers and ask the reducer for its data.</p>
	 	<p>You can try the results bellow and they are...inconclusive for me. On my quad core computer if I have 4 map workers or less (plus 1 reduce worker) then the version that used structured cloning wins, but 6 map workers or more (plus 1 reduce worker) the version that uses transferable objects wins. The version bellow uses 5 map workers (plus 1 reduce worker)</p>
	 	<p>I'm assuming this has something to do with the balence between transfer speeds advantage for transferable objects vs the parsing advantage for the structured clones, also in case your curious all the way on the right is a version that just does it single threaded in the worker, takes over a minute for me.</p>
	 	</div>
	 </div>
<div class="row-fluid">
<div id="test-container" class="span4">
		<div id="test1"></div>
	</div>
	<div id="test-container" class="span4">
		<div id="test2"></div>
	</div>
	<div id="test-container" class="span4">
		<div id="test3"></div>
	</div>
</div>
	<div class="row-fluid" id="startWell"><div class="span4 well"><button id="startit" class="btn btn-primary" >download dictionrary</button><span class="label label-important" id="startWarn">28MiB</span></div></div>
<div class="row-fluid" style="display:none;" id="buttons">
	<div class="span4" id="b1">
		<button type="button" id="regular" class="btn btn-primary">Transfer with structured clone</button>
		<div id="out1"></div>
	</div>
	<div class="span4" id="b2">
		<button type="button" id="transferobj" class="btn btn-primary">Transfer with transferable objects</button>
		<div id="out2"></div>
	</div>
	<div class="span4" id="b3">
		<button type="button" id="inW" class="btn btn-primary">Map reduce in the Worker</button>
		<div id="out3"></div>
	</div>
</div>
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"> </script>
<script>
function animateSquare() {
	var test1 = document.getElementById('test1'),
	test2 = document.getElementById('test2'),
	test3 = document.getElementById('test3'),
		start = Date.now();

	window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame ||
                                   window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.setTimeout;

	function step() {
		var now = Date.now(),
			progress = now - start;

		if (progress > 5000) {
			progress = 0;
			start = now;
		}

		test1.style.left = (progress / 10) + "px";
test2.style.left = (progress / 10) + "px";
test3.style.left = (progress / 10) + "px";
		requestAnimationFrame(step);
	}

	requestAnimationFrame(step);
}


animateSquare();
</script>
<script src="https://raw.github.com/tildeio/rsvp.js/master/browser/rsvp.js"></script>
<script src="https://raw.github.com/timrwood/moment/2.0.0/moment.js"></script>
<script src="communist.js"></script>
<script>
var dict;
var wFunc=function(data,callback){
	var ajax = function (url, cb) {
			var request = new XMLHttpRequest();
			request.open("GET", url);
				request.onreadystatechange = function() {
					if (request.readyState === 4 && request.status === 200) {
						cb(request.responseText);
						}
				};
			request.send();
		};
	var mFunc=function(dd){
		var out={};
		dd.split("").filter(function(v){return v.trim()!=="";}).forEach(function(v){
			if(out[v]){
				out[v]=out[v]+1;
			}else{
				out[v]=1;
			}
		});
		return out;
	};
	var rFunc = function(a,b){
		var out = {};
		Object.keys(a).forEach(function(v){
			out[v]=a[v];
		});
		Object.keys(b).forEach(function(v){
			if(out[v]){
				out[v]=out[v]+b[v];
			}else{
				out[v]=b[v];
			}
		});
		return out;
	};
	function fromText(text){
	var len = text.length;
	var ab = new Uint16Array(len);
	var i = 0;
	while(i<len){
		ab[i]=text.charCodeAt(i);
		i++;
	}
	return ab.buffer;
}
function toA(a,size){
	var sliceList=[];
	var len = a.byteLength;
	var start = 0;
	var end = len%size;
	while(end<len){
		sliceList.push([start,end]);
		start = end;
		end = end + size;
	}
	return sliceList.map(function(v){return a.slice(v[0],v[1])});
}
function inA(a,size){
	var sliceList=[];
	var len = a.length;
	var start = 0;
	var end = len%size;
	while(end<len){
		sliceList.push([start,end]);
		start = end;
		end = end + size;
	}
	return sliceList.map(function(v){return a.slice(v[0],v[1])});
}
var rb;
	if(data[0]==="s"){
		ajax(data[1],function(resp){	
			_db.text = resp;
			callback(_db.text.length);
		});
	}else if(data==="r"){
		if(_db.text){
		callback(inA(_db.text,5000));
		}else{
			callback("oh shit " + _db.text);
		}
	}else if(data==="t"){
		rb = toA(fromText(_db.text),10000);
		callback(rb,rb);
	}else if(data==="g"){
			rb = fromText(_db.text);
		callback(rb,[rb]);
	}else if(data==="c"){
		callback(_db.text.split("\n").map(mFunc).reduce(rFunc,{}));
	}
};
var c = communist(wFunc);

var startButton = $("#startit");
startButton.on("click",function(){
startButton.addClass("disabled").html("loading...");
$("#startWarn").html("");
var starting = c.data(["s",communist.makeUrl("dictionary.txt")]);
starting.then(function(a){
	var reg,trn,inW,tasb;
	if(a>0){
		$("#startWell").css("display","none");
		$("#buttons").css("display","block");
		reg = $("#regular");
		reg.one("click",function(){
			reg.addClass("disabled").html("structured cloning...");
			var t1 = moment();
			c.data("r").then(function(a){
				var t2 = moment();
				var dur = parseInt(moment.duration(t2.diff(t1)).asMilliseconds(),10);
				var nt = "took " + dur + " milliseconds, parse letter frequencies?";
				reg.removeClass("disabled").html(nt);
				dict = a;
				reg.one("click",function(){
					reg.addClass("disabled").html("getting my map reduce on");
					var t1 = moment();
					var c2 = communist(5,true).map(function(dd){
							var out={};
							dd.split("").filter(function(v){return v.trim()!=="";}).forEach(function(v){
								if(out[v]){
									out[v]=out[v]+1;
								}else{
									out[v]=1;
								}
							});
							return out;
						});
					c2.reduce(function(a,b){
						var out = {};
						Object.keys(a).forEach(function(v){
							out[v]=a[v];
						});
						Object.keys(b).forEach(function(v){
							if(out[v]){
								out[v]=out[v]+b[v];
							}else{
								out[v]=b[v];
							}
						});
						return out;
					}).data(a);
					c2.fetch().then(function(b){
						$("#out1").html('<table class="table table-striped table-bordered table-hover"><thead><th>character</th><th>count</th></thead><tbody>'+Object.keys(b).sort(function(a1,b1){return b[b1]-b[a1];}).map(function(v){return "<tr><td>'"+v+"'</td><td>"+b[v]+"</td></tr>";}).join("")+'</tbody></table>');
						var t2 = moment();
						reg.css("display","none");
						var tot = parseInt(moment.duration(t2.diff(t1)).asMilliseconds(),10);
						$("#b1").prepend( "<span class='label label-inverse'>took " + tot/1000 + " seconds to parse plus " + dur + " milliseconds to transfer for " + ((tot+dur)/1000) +" total</span>");

					});
				});
			},function(a){console.log(a)});
			
		});
		trn = $("#transferobj");
		trn.one("click",function(){
			trn.addClass("disabled").html("transfering...");
			var t1 = moment();
			c.data("t").then(function(dd){
				var t2 = moment();
				dict = dd;
				var dur = parseInt(moment.duration(t2.diff(t1)).asMilliseconds(),10);
				var nt = "took " + dur + " milliseconds, parse letter frequencies?";
				trn.removeClass("disabled").html(nt);
				trn.one("click",function(){
					var t1 = moment();
					trn.addClass("disabled").html("getting my map reduce on");
				var c3 = communist(5,true);
					c3.map(function(d,cb){
						var dd = String.fromCharCode.apply(null, new Uint16Array(d));
						var out={};
						dd.split("").filter(function(v){return v.trim()!=="";}).forEach(function(v){
							if(out[v]){
								out[v]=out[v]+1;
							}else{
								out[v]=1;
							}
						});
					return out;
				},true);
				c3.reduce(function(a,b){
					var out = {};
					Object.keys(a).forEach(function(v){
						out[v]=a[v];
					});
					Object.keys(b).forEach(function(v){
						if(out[v]){
							out[v]=out[v]+b[v];
						}else{
							out[v]=b[v];
						}
					});
					return out;
				});
				c3.data(dd);
				c3.fetch().then(function(a){
					$("#out2").html('<table class="table table-striped table-bordered table-hover"><thead><th>character</th><th>count</th></thead><tbody>'+Object.keys(a).sort(function(a1,b1){return a[b1]-a[a1];}).map(function(v){return "<tr><td>'"+v+"'</td><td>"+a[v]+"</td></tr>";}).join("")+'</tbody></table>');
					var t2 = moment();
					trn.css("display","none");
					var tot = parseInt(moment.duration(t2.diff(t1)).asMilliseconds(),10);
					$("#b2").prepend( "<span class='label label-inverse'>took " + tot/1000 + " seconds to parse plus " + dur + " milliseconds to transfer for " + ((tot+dur)/1000) +" seconds total</span>");
				});
			});
			},function(a){console.log(a)});
			
		});
		inW= $("#inW");
		inW.one("click",function(){
			var t1 = moment();
			inW.addClass("disabled").html("getting my map reduce on");
			c.data("c").then(function(a){
				$("#out3").html('<table class="table table-striped table-bordered table-hover"><thead><th>character</th><th>count</th></thead><tbody>'+Object.keys(a).sort(function(a1,b1){return a[b1]-a[a1];}).map(function(v){return "<tr><td>'"+v+"'</td><td>"+a[v]+"</td></tr>";}).join("")+'</tbody></table>');
				var t2 = moment();
				inW.css("display","none");
				var tot = parseInt(moment.duration(t2.diff(t1)).asSeconds(),10);
				$("#b3").prepend( "<span class='label label-inverse'>took " + tot + " seconds to parse</span>");

			});
		});
		tasb = $("#transArray");
		tasb.removeClass("disabled");
		tasb.one("click",function(){
			tasb.addClass("disabled").html("loading");
			var t1 = moment();
			c.data("g").then(function(a){
				var t2 = moment();
				var tot = moment.duration(t2.diff(t1)).asMilliseconds();
				tasb.css("display","none");
				$("#tas").prepend("<span class='label label-inverse'>took " + tot + " milliseconds</span>");
			});
		});
	}
});
});


</script></body></html>